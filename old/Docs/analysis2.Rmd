---
title: "R Notebook"
output: html_notebook
--

This segment will load in the test case data and create the basic
constants.

```{r}
#Get the test cases
new_bins_new_data = read.csv("testresults_NN.csv")
old_bins_new_data = read.csv("testresults_ON.csv")

#Get the test cases for each algorithm
alg = list(8)
alg[[1]] = new_bins_new_data[which(new_bins_new_data$algorithm == 1),]
alg[[2]] = new_bins_new_data[which(new_bins_new_data$algorithm == 2),]
alg[[3]] = new_bins_new_data[which(new_bins_new_data$algorithm == 3),]
alg[[4]] = new_bins_new_data[which(new_bins_new_data$algorithm == 4),]
alg[[5]] = old_bins_new_data[which(old_bins_new_data$algorithm == 1),]
alg[[6]] = old_bins_new_data[which(old_bins_new_data$algorithm == 2),]
alg[[7]] = old_bins_new_data[which(old_bins_new_data$algorithm == 3),]
alg[[8]] = old_bins_new_data[which(old_bins_new_data$algorithm == 4),]

#The list of the different scan periods
intervals = list(4)
intervals[[1]] = 2
intervals[[2]] = 3
intervals[[3]] = 5
intervals[[4]] = 10
```


This segment removes known fake test cases from the data set.

```{r}
for(i in 1:8)
{
  alg[[i]] = alg[[i]][which(alg[[i]]$testid != "FAKE_TEST"),]
  alg[[i]] = alg[[i]][which(alg[[i]]$testid != "FAKE_TEST_2"),]
  alg[[i]] = alg[[i]][which(alg[[i]]$testid != "FAKE_TEST_3"),]
  
  alg[[i]] = alg[[i]][which(alg[[i]]$error < 20),]
}

#Recreate the master data frames

new_bins_new_data = alg[[1]]
old_bins_new_data = alg[[5]]

for(i in 2:4) {
  new_bins_new_data = rbind(new_bins_new_data, alg[[i]])
  old_bins_new_data = rbind(old_bins_new_data, alg[[i+4]])
}
```



This segment computes some statistics for each algorithm and scanning period.

```{r}
assign("means", matrix(1:32, nrow=8, ncol=4), envir=.GlobalEnv)
assign("sds", matrix(1:32, nrow=8, ncol=4), envir=.GlobalEnv)

#Get stats for new binnning strategy and old binning strategy for an algorithm
get_alg_stats_for_int = function(sub, int_id, alg_id)
{
  if(nrow(sub[[alg_id]]) == 0)
    return()
  if(nrow(sub[[alg_id+4]]) == 0)
    return()
  
  means[[alg_id, int_id]] = mean(sub[[alg_id]]$error)
  sds[[alg_id, int_id]] = sd(sub[[alg_id]]$error)
  means[[alg_id+4, int_id]] = mean(sub[[alg_id+4]]$error)
  sds[[alg_id+4, int_id]] = sd(sub[[alg_id+4]]$error)
  
  assign("means", means, envir=.GlobalEnv,inherits=TRUE)
  assign("sds", sds, envir=.GlobalEnv, inherits=TRUE)
  
  string=paste0("   (algorithm:", alg_id, "): \n")
  string=paste0(string, "      new_mean:               ", means[[alg_id, int_id]], "\n")
  string=paste0(string, "      new_dev:                ", sds[[alg_id, int_id]], "\n")
  string=paste0(string, "      old_mean:               ", means[[alg_id+4, int_id]], "\n")
  string=paste0(string, "      old_dev:                ", sds[[alg_id+4, int_id]], "\n")
  cat(string)
}

#Get stats for an algorithm at a certain interval
get_alg_stats = function(alg, interval, int_id, building, floor, top_n)
{
  sub = list(8)
  
  string=paste0("Stats for ", building, " floor ", floor, " at an interval of ", interval, " seconds\n")
  cat(string)
  
  #Remove FAKE_TEST, FAKE_TEST_1, and FAKE_TEST_2
  #Only select observations from floor 1
  #Only select observations from SB
  #Only select observations with a duration of interval seconds
  #Only select observations where top_n beacons were used in the location approximation
  for(i in 1:8)
  {
    sub[[i]] = alg[[i]][which(alg[[i]]$floor_true == floor),]
    sub[[i]] = sub[[i]][which(sub[[i]]$building == building),]
    sub[[i]] = sub[[i]][which(sub[[i]]$duration == interval),]
    sub[[i]] = sub[[i]][which(sub[[i]]$top_n_beacons == top_n),]
  }
  
  get_alg_stats_for_int(sub, int_id, 1)
  get_alg_stats_for_int(sub, int_id, 2)
  get_alg_stats_for_int(sub, int_id, 3)
  get_alg_stats_for_int(sub, int_id, 4)
}

get_alg_stats(alg, 2, 1, "SB", 1, 3)
get_alg_stats(alg, 3, 2, "SB", 1, 3)
get_alg_stats(alg, 5, 3, "SB", 1, 3)
get_alg_stats(alg, 10, 4, "SB", 1, 3)
```


This function trims the data set so that records whose error is above a certain percentile are discarded. Currently, I don't use this function.

```{r}
trim = .05

#All datasets have the same length
to_rm = rep(c(TRUE), times=nrow(alg[[1]]))

#For each algorithm and data age
for(i in 1:8) {
  
  #For each interval
  for(j in 1:4) {
    
    #For each record for the algorithm
    for(k in 1:nrow(alg[[i]]))
    {
      #Get the error in distance
      error = alg[[i]]$error[k]
      
      #Compute how relatively accurate this error is
      score = (error - means[[i, j]])/sds[[i, j]]
      
      #Top trim %
      if(pnorm(score) > 1 - trim) {
        to_rm[k]=FALSE
      }
      
      #Bottom trim %
      if(pnorm(score) < trim) {
        to_rm[k]=FALSE
      }
    }
  }
}

#Actually remove elements from the data frames
for(i in 1:8) {
  alg[[i]] = alg[[i]][to_rm,]
}

#Recreate the master data frames

new_bins_new_data = alg[[1]]
old_bins_new_data = alg[[5]]

for(i in 2:4) {
  new_bins_new_data = rbind(new_bins_new_data, alg[[i]])
  old_bins_new_data = rbind(old_bins_new_data, alg[[i+4]])
}
```


This segment creates the functions to create the box plots of error for each algorithm under different time intervals.

```{r}
create_dur_boxplot = function(sub, i)
{
  sub1 = sub[which(sub$duration == i),]
  title = paste0("Int ", i)
  if(nrow(sub1) == 0)
    return()
  boxplot(error~algorithm, data=sub1, main = title, xlab="Algorithm ID", ylab = "Error (m)")
}

create_dur_boxplots = function(alg, intervals, building, floor, top_n)
{
  #Only select observations from floor 1
  sub = alg[which(alg$floor_true == floor),]
  
  #Only select observations from SB
  sub = sub[which(sub$building == building),]
  
  #Only select observations where top_n beacons were used in the location approximation
  sub = sub[which(sub$top_n_beacons == top_n),]
  
  for(i in 1:length(intervals))
    create_dur_boxplot(sub, intervals[[i]])
}

create_dur_boxplot_file = function(alg, intervals, building, floor, top_n)
{
  filename = paste0("./DurVDurBoxPlot-")
  filename = paste0(filename, "Build ", building, "-")
  filename = paste0(filename, "Floor ", floor, "-")
  filename = paste0(filename, "TopN ", top_n, ".png")
  
  print(filename)
  png(filename)
  par(mfrow=c(2,2))
  create_dur_boxplots(new_bins_new_data, intervals, building, 1, 3)
}

create_dur_boxplot_file(new_bins_new_data, intervals, "SB", 1, 3)

while(dev.off())
{
}
```

This segment creates the functions to create the histograms of error for each algorithm under different time intervals.

```{r}
create_dur_hist = function(sub, alg_id, i)
{
  sub1 = sub[which(sub$duration == i),]
  title = paste0("Alg ", alg_id, ", Int ", i)
  if(nrow(sub1) == 0)
    return()
  hist(sub1$error, breaks=8, main = title, xlab="Error (m)")
}

create_dur_hists = function(alg, alg_id, intervals, building, floor, top_n)
{
  #Only select observations from floor 1
  #Only select observations from SB
  #Only select observations with a duration of interval seconds
  #Only select observations where top_n beacons were used in the location approximation
  sub = alg[[alg_id]]
  sub = sub[which(sub$floor_true == floor),]
  sub = sub[which(sub$building == building),]
  sub = sub[which(sub$top_n_beacons == top_n),]
  
  filename = paste0("./DurVDurHist-")
  filename = paste0(filename, "Alg ", alg_id, "-")
  filename = paste0(filename, "Build ", building, "-")
  filename = paste0(filename, "Floor ", floor, "-")
  filename = paste0(filename, "TopN ", top_n, ".png")
  png(filename)
  par(mfrow=c(2,2))
  
  for(i in 1:length(intervals))
    create_dur_hist(sub, alg_id, intervals[[i]])
}

create_dur_hists(alg, 1, intervals, "SB", 1, 3)
create_dur_hists(alg, 2, intervals, "SB", 1, 3)
create_dur_hists(alg, 3, intervals, "SB", 1, 3)
create_dur_hists(alg, 4, intervals, "SB", 1, 3)

while(dev.off())
{
}
```


This segment compares the effectiveness the new binning strategy as compared to the original binning strategy on the new data.

```{r}
#Compare new binnning strategy to old binning strategy for an algorithm
compare_bins = function(sub, alg_id)
{
  if(nrow(sub[[alg_id]]) == 0)
    return()
  if(nrow(sub[[alg_id+4]]) == 0)
    return()
  
  t_val = t.test(sub[[alg_id]]$error, sub[[alg_id+4]]$error, paired=TRUE)
  string=paste0("   (algorithm: ", alg_id, "): \n")
  string=paste0(string, "      p Value:                ", t_val$p.value, "\n")
  cat(string)
  
  diff = sub[[alg_id]]$error - sub[[alg_id+4]]$error
  hist(diff, breaks=100, main = paste0("Algorithm ", alg_id), xlab="Error Difference (m)")
}

new_v_old_bins = function(alg, interval, building, floor, top_n)
{
  sub = list(8)
  
  string=paste0("New Bins V Old For ", building, " floor ", floor, " at an interval of ", interval, " seconds\n")
  cat(string)
  
  #Remove FAKE_TEST, FAKE_TEST_1, and FAKE_TEST_2
  #Only select observations from floor 1
  #Only select observations from SB
  #Only select observations with a duration of interval seconds
  #Only select observations where top_n beacons were used in the location approximation
  for(i in 1:8)
  {
    sub[[i]] = alg[[i]][which(alg[[i]]$testid != "FAKE_TEST"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$testid != "FAKE_TEST_2"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$testid != "FAKE_TEST_3"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$floor_true == floor),]
    sub[[i]] = sub[[i]][which(sub[[i]]$building == building),]
    sub[[i]] = sub[[i]][which(sub[[i]]$duration == interval),]
    sub[[i]] = sub[[i]][which(sub[[i]]$top_n_beacons == top_n),]
  }
  
  png("./Figure.png")
  par(mfrow=c(2,2))
  
  compare_bins(sub, 1)
  compare_bins(sub, 2)
  compare_bins(sub, 3)
  compare_bins(sub, 4)
  
  dev.off()
}

new_v_old_bins(alg, 1, "SB", 1, 3)
new_v_old_bins(alg, 2, "SB", 1, 3)
new_v_old_bins(alg, 3, "SB", 1, 3)
new_v_old_bins(alg, 5, "SB", 1, 3)
new_v_old_bins(alg, 10, "SB", 1, 3)
```


This segment compares the different algorithms under the new binning strategy on the new data for each interval.

```{r}
compare_algorithms = function(sub, i, j, interval, building, floor)
{
  if(nrow(sub[[i]]) == 0)
    return()
  if(nrow(sub[[j]]) == 0)
    return()
  
  
  t_val = t.test(sub[[i]]$error, sub[[j]]$error, paired=TRUE)
  
  string=paste0("  (floor: ", floor, ", algorithms: ", i, " and ", j, "): \n")
  string=paste0(string, "   p Value:                ", t_val$p.value, "\n")
  cat(string)
  
  hist(sub[[i]]$error - sub[[j]]$error, main = paste0(i, " v ", j), xlab="Error Difference (m)")
}

compare_new_algorithms = function(alg, interval, building, floor, top_n)
{
  sub = list(4)
  
  string=paste0("Algorithm v Algorithm For ", building, " floor ", floor, " at an interval of ", interval, " seconds\n")
  cat(string)
  
  #Remove FAKE_TEST, FAKE_TEST_1, and FAKE_TEST_2
  #Only select observations from floor 1
  #Only select observations from SB
  #Only select observations with top 3 beacons
  for(i in 1:4)
  {
    sub[[i]] = alg[[i]][which(alg[[i]]$testid != "FAKE_TEST"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$testid != "FAKE_TEST_2"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$testid != "FAKE_TEST_3"),]
    sub[[i]] = sub[[i]][which(sub[[i]]$floor_true == floor),]
    sub[[i]] = sub[[i]][which(sub[[i]]$building == building),]
    sub[[i]] = sub[[i]][which(sub[[i]]$duration == interval),]
    sub[[i]] = sub[[i]][which(sub[[i]]$top_n_beacons == top_n),]
  }
  
  #Compare the effectiveness of each algorithm
  string="./CompareAlgorithms-"
  string=paste0(string, building, "-")
  string=paste0(string, floor, "-")
  string=paste0(string, "Top", top_n, "-")
  string=paste0(string, "Int", interval, ".png")
  png(string)
  par(mfrow=c(4,4))
  
  #Compare the effectiveness of algorithm i against algorithm j
  for(i in 1:4){
    for(j in 1:4) { 
      compare_algorithms(sub, i, j, interval, building, floor)
    }
  }
}

compare_new_algorithms(alg, 2, "SB", 1, 3)
compare_new_algorithms(alg, 3, "SB", 1, 3)
compare_new_algorithms(alg, 5, "SB", 1, 3)
compare_new_algorithms(alg, 10, "SB", 1, 3)

while(dev.off())
{
}
```



This segment compares each algorithm with itself at different durations. This is to show whether
or not the scanning period can be lowered.

```{r}
#Compare the error of the algorithm at intervals i1 and i2
compare_intervals = function(sub, alg_id, i1, i2)
{
  if(nrow(sub[[alg_id]]) == 0)
    return()
  
  sub1 = sub[[alg_id]][which(sub[[alg_id]]$duration == i1),]
  sub2 = sub[[alg_id]][which(sub[[alg_id]]$duration == i2),]
  
  if(nrow(sub1) == 0 || nrow(sub2) == 0)
    return()
  
  t_val = t.test(sub1$error, sub2$error, paired=FALSE)
  
  string=paste0("  (i1: ", i1, ", i2: ", i2, "): \n")
  string=paste0(string, "      p Value:                ", t_val$p.value, "\n")
  cat(string)
}

compare_algorithm_intervals = function(alg, alg_id, intervals, building, floor, top_n)
{
  sub = list(4)
  
  string=paste0("Interval v Interval For ", building, " floor ", floor, " for algorithm ", alg_id, "\n")
  cat(string)
  
  #Remove FAKE_TEST, FAKE_TEST_1, and FAKE_TEST_2
  #Only select observations from floor 1
  #Only select observations from SB
  #Only select observations with top 3 beacons
  for(i in 1:4)
  {
    sub[[i]] = alg[[i]][which(alg[[i]]$floor_true == floor),]
    sub[[i]] = sub[[i]][which(sub[[i]]$building == building),]
    sub[[i]] = alg[[i]][which(sub[[i]]$top_n_beacons == top_n),]
  }
  
  filename = paste0("./DurVDur-")
  filename = paste0(filename, "Alg ", alg_id, "-")
  filename = paste0(filename, "Build ", building, "-")
  filename = paste0(filename, "Floor ", floor, "-")
  filename = paste0(filename, "TopN ", top_n, ".png")
  png(filename)
  par(mfrow=c(4,4))
  
  for(i in 1:4){
    for(j in 1:4) { 
      compare_intervals(sub, alg_id, intervals[[i]], intervals[[j]])
    }
  }
}

compare_algorithm_intervals(alg, 1, intervals, "SB", 1, 3)
compare_algorithm_intervals(alg, 2, intervals, "SB", 1, 3)
compare_algorithm_intervals(alg, 3, intervals, "SB", 1, 3)
compare_algorithm_intervals(alg, 4, intervals, "SB", 1, 3)

while(dev.off())
{
}
```




